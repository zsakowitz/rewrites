Storymatic {
  Script = StatementBlock

  WrappedStatementBlock = "{" StatementBlock "}"

  StatementBlock
    = WrappedStatementBlock -- wrapped_block
    | Statement* -- statements

  SingleStatementBlock<prefix>
    = prefix? WrappedStatementBlock -- wrapped_block
    | prefix #(space+) Statement -- single_statement

  UnprefixedSingleStatementBlock
    = WrappedStatementBlock -- wrapped_block
    | Statement -- single_statement

  IfStatement = ("if" | "unless") #(space+) Expression SingleStatementBlock<"then"> ElseIfStatement* ElseStatement?
  ElseIfStatement = ElseIfKeyword #(space+) Expression SingleStatementBlock<"then">
  ElseStatement = "else" #(space+) UnprefixedSingleStatementBlock

  TryStatement = "try" #(space+) UnprefixedSingleStatementBlock CatchStatement? FinallyStatement?
  CatchStatement = "catch" #(space+) (identifier #(space+) "of" #(space+))? UnprefixedSingleStatementBlock
  FinallyStatement = "finally" #(space+) UnprefixedSingleStatementBlock

  ElseIfKeyword
    = "else" "if" -- else_if
    | "elif" -- elif

  Statement
    = Expression #statementTerminator -- expression
    | IfStatement
    | TryStatement
    | BlockFunction
    | ClassDeclaration
    | "print" #(space+) Expression #statementTerminator -- print
    | "throw" #(space+) Expression #statementTerminator -- throw
    | "repeat" #(space+) Expression SingleStatementBlock<"do"> -- repeat
    | "while" #(space+) Expression SingleStatementBlock<"do"> -- while
    | "until" #(space+) Expression SingleStatementBlock<"do"> -- until
    | "do" #(space+) UnprefixedSingleStatementBlock #(space+) "while" #(space+) Expression -- do_while
    | "do" #(space+) UnprefixedSingleStatementBlock #(space+) "until" #(space+) Expression -- do_until
    | "for" #(space+) ForLoopKey #(space+) "in" #(space+) Expression SingleStatementBlock<"do"> -- for_key
    | "for" #(space+) "(" identifier? "," identifier? ")" #(space+) "in" #(space+) Expression SingleStatementBlock<"do"> -- for_key_value
    | "for" #(space+) ForLoopKey #(space+) "of" #(space+) Expression SingleStatementBlock<"do"> -- iterate_over
    | "for" #(space+) "(" identifier? "," identifier? ")" #(space+) "of" #(space+) Expression SingleStatementBlock<"do"> -- iterate_indices
    | "break" #statementTerminator -- break
    | "continue" #statementTerminator -- continue
    | "return" #(space+) Expression #statementTerminator -- return
    | "for" #(space+) identifier
      (#(space+) "from" #(space+) Expression)? (#(space+) ("to" | "through") #(space+) Expression)?
      (#(space+) "step" #(space+) Expression)? SingleStatementBlock<"do"> -- count
    | "await" #(space+) (identifier "=")? Expression SingleStatementBlock<"do"> -- await_new_thread
    | "await" #(space+) (identifier "=")? Expression #statementTerminator -- await_main_thread
    | "when" #(space+) Expression ("with" ArgumentList)? SingleStatementBlock<"do"> -- when_callback
    | "import" #(space+) string_non_interpolatable #statementTerminator -- empty_import
    | "import" #(space+) ListOf<ImportableItemName, ","> #(space+) "from" #(space+) string_non_interpolatable #statementTerminator -- import
    | "import" "*" "as" #(space+) identifier #(space+) "from" #(space+) string_non_interpolatable #statementTerminator -- import_all
    | "import" "*" identifier #(space+) "from" #(space+) string_non_interpolatable #statementTerminator -- import_default
    | "export" #statementTerminator -- empty_export
    | "export" #(space+) ListOf<ImportableItemName, ","> #(space+) "from" #(space+) string_non_interpolatable #statementTerminator -- export_from
    | "export" "*" "from" #(space+) string_non_interpolatable #statementTerminator -- export_all_from
    | "export" #(space+) ListOf<ImportableItemName, ","> #statementTerminator -- export
    | "export" "*" Expression #statementTerminator -- export_default
    | "export" #(space+) ClassDeclaration -- export_class
    | "export" #(space+) VariableAssignment -- export_variable
    | "export" #(space+) BlockFunction -- export_function

  ClassDeclaration = "class" #(space+) identifier ("extends" Expression)? "{" ClassElement* "}"

  ClassElement
    = Method<"@"> -- method
    | Method<"@@"> -- static_method
    | property "=" Expression #statementTerminator -- property
    | staticProperty "=" Expression #statementTerminator -- staticProperty

  ImportableItemName
    = identifier #(space+) "as" #(space+) identifier -- identifier_rewrite
    | string_non_interpolatable #(space+) "as" #(space+) identifier -- string_rewrite
    | identifier

  ForLoopKey
    = "(" identifier ")" -- parenthesized
    | identifier

  statementTerminator
    = spaces ";" -- semicolon
    | spaces &reserved_block -- keyword
    | spaces &"}" -- block_end
    | spaces end -- script_end
    | lineTerminator -- newline

  expressionTerminator
    = spaces "," -- comma
    | spaces &reserved_block -- keyword
    | spaces &"}" -- block_end
    | spaces end -- script_end
    | lineTerminator -- newline

  lineTerminator = whitespace? ("\r" | "\n")+ spaces ~lineContinuer
  lineContinuer
    = "+" | "-" | "*" | "/" | "^" | "%" | "==" | "!=" | "[" | "(" | "." | "?." | "?" | ":" | "<" | ">" | "&&" | "||" | "??" | reserved_operators

  Expression = AssignmentExp

  LiteralExp
    = "(" Expression ")" -- parenthesized
    | "[" ListOf<ArrayEntry, expressionTerminator> expressionTerminator? "]" -- array
    | "{" ListOf<ObjectEntry, expressionTerminator> expressionTerminator? "}" -- object
    | InlineFunction
    | decimalNumber
    | unitNumber
    | hexNumber
    | bigint
    | identifier
    | property
    | staticProperty
    | symbol
    | boolean
    | string
    | null

  ArrayEntry
    = Expression
    | "..." Expression -- spread_operator

  InlineFunction
    = "fn" #(space+) ":"? Expression -- expression
    | "fn" #(space+) ":"? WrappedStatementBlock -- wrapped_block
    | "fn" #(space+) "of" #(space+) ParameterList ":" Expression -- params_and_expression
    | "fn" #(space+) "of" #(space+) ParameterList ":"? WrappedStatementBlock -- params_and_wrapped_block

  BlockFunction
    = "fn" #(space+) identifier #(space+) ":" Expression -- expression
    | "fn" #(space+) identifier #(space+) ":"? WrappedStatementBlock -- wrapped_block
    | "fn" #(space+) identifier #(space+) "of" #(space+) ParameterList ":" Expression -- params_and_expression
    | "fn" #(space+) identifier #(space+) "of" #(space+) ParameterList ":"? WrappedStatementBlock -- params_and_wrapped_block

  Method<prefix>
    = "fn" #(space+) prefix MethodName #(space+) ":" Expression -- expression
    | "fn" #(space+) prefix MethodName #(space+) ":"? WrappedStatementBlock -- wrapped_block
    | "fn" #(space+) prefix MethodName #(space+) "of" #(space+) ParameterList ":" Expression -- params_and_expression
    | "fn" #(space+) prefix MethodName #(space+) "of" #(space+) ParameterList ":"? WrappedStatementBlock -- params_and_wrapped_block

  MethodName
    = identOrWord -- identifier
    | symbol -- symbol
    | string_non_interpolatable -- string_key
    | string -- computed_string_key
    | "[" Expression "]" -- computed_key

  ObjectEntry
    = identifier ~":" -- restructure
    | identOrWord ":" Expression -- key_value
    | symbol ":" Expression -- symbol_value
    | string_non_interpolatable ":" Expression -- string_key
    | string ":" Expression -- computed_string_key
    | digit+ ":" Expression -- numerical_key
    | "[" Expression "]" ":" Expression -- computed_key
    | "..." Expression -- spread_operator
    | Method<""> -- object_method

  MemberAccessExp
    = MemberAccessExp "." identOrWord -- member_access
    | MemberAccessExp "?." identOrWord -- optional_chaining_member_access
    | MemberAccessExp "." symbol -- symbol_access
    | MemberAccessExp "?." symbol -- optional_chaining_symbol_access
    | MemberAccessExp "[" MemberAccessExp "]" -- computed_member_access
    | MemberAccessExp "?." "[" MemberAccessExp "]" -- optional_chaining_computed_member_access
    | MemberAccessExp "(" ArgumentList ")" -- function_call
    | MemberAccessExp #(space+) "with" #(space+) ~"(" Expression -- function_call_worded
    | MemberAccessExp #(space+) "with" #(space+) "(" ArgumentList ")" -- function_call_worded_list
    | MemberAccessExp #(space+) ~identifier ArgumentList -- function_call_implied
    | ("a" | "an") #(space+) MemberAccessExp "(" ArgumentList ")" -- class_creation_args_symbolic
    | ("a" | "an") #(space+) MemberAccessExp #(space+) "with" #(space+) ~"(" Expression -- class_creation_args_worded
    | ("a" | "an") #(space+) MemberAccessExp #(space+) "with" #(space+) "(" ArgumentList ")" -- class_creation_args_worded_list
    | LiteralExp

  ArgumentList = ListOf<Argument, ",">
  NonEmptyArgumentList = NonemptyListOf<Argument, ",">

  Argument
    = Expression
    | "..." Expression -- spread_operator

  ParameterList = ListOf<Parameter, ","> ","?
  NonEmptyParameterList = NonemptyListOf<Parameter, ","> ","?

  Parameter
    = AssignableWithDefault
    | "..." Assignable -- rest_operator

  ClassCreationExp
    = ("a" | "an") #(space+) ClassCreationExp ~("with" | "(") -- class_creation
    | MemberAccessExp

  NotExp
    = "!" NotExp -- logical_not_symbolic
    | "not" #(space+) NotExp -- logical_not_worded
    | "+" ~digit NotExp -- unary_plus
    | "-" ~digit NotExp -- unary_minus
    | "type" "of" #(space+) NotExp -- typeof
    | "await" #(space+) NotExp -- await
    | ClassCreationExp

  ExpExp
    = ExpExp "^" NotExp -- exponentiate
    | NotExp

  MulExp
    = MulExp "*" ExpExp -- multiplication
    | MulExp "/" ExpExp -- division
    | MulExp "%" ExpExp -- modulus
    | ExpExp

  AddExp
    = AddExp "+" MulExp -- addition
    | AddExp "-" MulExp -- subtraction
    | MulExp

  CompareExp
    = CompareExp "<" AddExp -- less_than
    | CompareExp "<=" AddExp -- less_than_equal
    | CompareExp ">" AddExp -- greater_than
    | CompareExp ">=" AddExp -- greater_than_equal
    | CompareExp #(space+) ("is" #(space+))? "in" #(space+) AddExp -- within
    | CompareExp #(space+) "isnt" #(space+) "in" #(space+) AddExp -- not_within
    | CompareExp #(space+) "is" #(space+) ("a" | "an") #(space+) AddExp -- instanceof
    | CompareExp #(space+) "isnt" #(space+) ("a" | "an") #(space+) AddExp -- not_instanceof
    | AddExp

  EqualityExp
    = EqualityExp ("==" | EqualityExpWords<"is">) CompareExp -- equal_to
    | EqualityExp ("!=" | EqualityExpWords<"isnt">) CompareExp -- not_equal_to
    | CompareExp
  
  EqualityExpWords<keyword> = #(space+ keyword ~(space+ ("a" | "an")) space+)

  LogicalAndExp
    = LogicalAndExp #(spaces "&&" spaces | space+ "and" space+) EqualityExp -- logical_and
    | EqualityExp
  
  LogicalOrExp
    = LogicalOrExp #(spaces "||" spaces | space+ "or" space+) LogicalAndExp -- logical_or
    | LogicalOrExp "??" LogicalAndExp -- logical_nullish_coalescing
    | LogicalAndExp

  TernaryExp
    = LogicalOrExp "?" TernaryExp ":" TernaryExp -- symbolic
    | "if" #(space+) LogicalOrExp #(space+) "then" #(space+) TernaryExp #(space+) "else" #(space+) TernaryExp -- worded
    | LogicalOrExp

  AssignmentExp
    = AssignableOrAccessor "=" AssignmentExp -- assignment
    | "yield" #(space+) AssignmentExp -- yield
    | "yield" #(space+ "from" | "*") #(space+) AssignmentExp -- yield_from
    | TernaryExp

  VariableAssignment = Assignable "=" Expression

  AssignableWithDefault
    = Assignable "=" Expression -- with_default
    | Assignable

  IdentifierWithDefault
    = identifier "=" Expression -- with_default
    | identifier

  AssignableKeyWithRewrite
    = identifier ":" AssignableWithDefault -- standard_rewrite
    | string_non_interpolatable ":" AssignableWithDefault -- string_rewrite
    | string ":" AssignableWithDefault -- computed_string_rewrite
    | "[" Expression "]" ":" AssignableWithDefault -- computed_rewrite
    | IdentifierWithDefault

  AssignableOrAccessor = Assignable | Accessor

  Assignable
    = identifier -- identifier
    | "[" ListOf<AssignableWithDefault, ","> ("," "..." Assignable)? ","? "]" -- array
    | "{" ListOf<AssignableKeyWithRewrite, ","> ("," "..." Assignable)? ","? "}" -- object

  Accessor
    = identifier
    | property
    | staticProperty
    | Accessor "." identOrWord -- member_access
    | Accessor "." symbol -- symbol_access
    | Accessor "[" Expression "]" -- computed_member_access

  whitespace = (~("\n" | "\r") space)+

  sign = ("+" | "-")?
  number = digit+
  unitNumber = ~"0x" sign digit+ ("." digit+)? ("e" sign digit+)? identifierWord
  decimalNumber = ~"0x" sign digit+ ("." digit+)? ("e" sign digit+)? ~char
  hexNumber = sign "0x" hexDigit+
  bigint = ~"0x" sign digit+ "n"

  boolean = "true" | "false"
  null = "null"

  id_continue = letter | digit

  string_bit<delimeter>
    = ~("\\" | "{" | delimeter) any -- character
    | "\\" ("\\" | "{" | "\"" | "'") -- escape
    | "\\" ("b" | "f" | "n" | "r" | "t" | "v" | ("0" ~digit)) -- escape_sequence
    | "\\x" hexDigit hexDigit -- hex_sequence
    | "\\u" hexDigit hexDigit hexDigit hexDigit -- unicode_sequence
    | "\\u{" hexDigit+ "}" -- unicode_code_point_sequence

  string_interpolatable_bit<delimeter>
    = string_bit<delimeter>
    | "{" applySyntactic<Expression> "}" -- interpolated
  
  string_interpolatable<delimeter> = delimeter string_interpolatable_bit<delimeter>* delimeter
  string_full<delimeter> = delimeter string_bit<delimeter>* delimeter
  string = string_interpolatable<"\""> | string_interpolatable<"'">
  string_non_interpolatable = string_full<"\""> | string_full<"'">

  reserved_block = ("if" | "elif" | "else" | "elseif" | "then" | "print" | "throw" | "for" | "while" | "until" | "unless" | "do" | "repeat" | "step" | "to" | "through" | "return" | "break" | "continue" | "fn" | "when" | "import" | "export" | "class" | "try" | "catch" | "finally") ~id_continue
  reserved_operators = ("and" | "or" | "not" | ("is" ~"nt") | "isnt" | "with") ~id_continue
  reserved_inline = ("a" | "an" | "in" | "type" | "of" | "from" | "typeof" | "emits" | "as" | "extends" | "await") ~id_continue
  reserved_primitive = ("true" | "false" | "null") ~id_continue
  reserved = reserved_block | reserved_operators | reserved_inline | reserved_primitive

  char = letter | "_"
  word = nonemptyListOf<char+, digit+>
  identifierWord = ~reserved word
  identifierWords = identifierWord (whitespace (identifierWord | digit+))*
  identifier = identifierWords
  identOrWord = identifier | word

  property = "@" spaces identOrWord
  staticProperty = "@@" spaces identOrWord

  symbol
    = "#" spaces identOrWord -- symbol_for
    | "##" spaces identOrWord -- builtin_symbol
}
